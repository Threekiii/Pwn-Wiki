# Assembly-Language | 汇编语言

- [Assembly-Language | 汇编语言](#assembly-language--汇编语言)
	- [第 1 章 基础知识](#第-1-章-基础知识)
		- [1.1 机器语言](#11-机器语言)
		- [1.2 汇编语言](#12-汇编语言)
		- [1.3 指令和数据](#13-指令和数据)
		- [1.4 存储单元](#14-存储单元)
		- [1.5 CPU 对存储器的读写](#15-cpu-对存储器的读写)
		- [1.6 总线](#16-总线)
		- [1.7 存储器芯片](#17-存储器芯片)
	- [第 2 章 寄存器](#第-2-章-寄存器)
		- [2.1 通用寄存器](#21-通用寄存器)
		- [2.2 字在寄存器中的存储](#22-字在寄存器中的存储)
		- [2.3 几条汇编指令](#23-几条汇编指令)
		- [2.4 物理地址](#24-物理地址)
		- [2.5 段寄存器](#25-段寄存器)
	- [第3章 寄存器（内存访问）](#第3章-寄存器内存访问)
		- [3.1 内存中字的存储](#31-内存中字的存储)
		- 3.2 DS 和 \[address\]
		- [3.3 字的传送](#33-字的传送)
		- [3.4 mov指令](#34-mov指令)
		- [3.5 数据段](#35-数据段)
		- [3.6 push、pop 指令](#36-pushpop-指令)
		- [3.7 段的综述](#37-段的综述)
	- 第 4 章 \[BX\] 和 loop 指令
		- 4.1 \[bx\]
		- [4.2 loop 指令](#42-loop-指令)
		- [4.3 段前缀](#43-段前缀)
	- [第 5 章 x86/x64 寄存器](#第-5-章-x86x64-寄存器)
		- [5.1 x86 架构](#51-x86-架构)
		- [5.2 x64 架构](#52-x64-架构)
	- [第 6 章 标志寄存器](#第-6-章-标志寄存器)
		- [6.1 ZF 标志](#61-zf-标志)
		- [6.2 PF 标志](#62-pf-标志)
		- [6.3 SF 标志](#63-sf-标志)
		- [6.4 CF 标志](#64-cf-标志)
		- [6.5 OF 标志](#65-of-标志)
		- [6.6 AF 标志](#66-af-标志)
	- [第 7 章 寻址方式](#第-7-章-寻址方式)
		- [7.1 立即寻址](#71-立即寻址)
		- [7.2 直接寻址](#72-直接寻址)
		- [7.3 寄存器寻址](#73-寄存器寻址)
		- [7.4 寄存器间接寻址](#74-寄存器间接寻址)
		- [7.5 基址寻址](#75-基址寻址)
		- [7.6 变址寻址](#76-变址寻址)
		- [7.7 基址加变址寻址](#77-基址加变址寻址)
	- [第 8 章 汇编指令](#第-8-章-汇编指令)


## 第 1 章 基础知识

### 1.1 机器语言

机器语言是机器指令的集合。机器指令展开来讲就是一台机器可以正确执行的命令。电子计算机的机器指令是一列二进制数字。计算机将之转变为一系列高低电平，以使计算机的电子器件受到驱动，进行运算。

早期的程序设计均使用机器语言。程序员们将用 0、1 数字编成的程序代码打在纸带或卡片上，1 打孔，0 不打孔，再将程序通过纸带机或卡片机输入计算机，进行运算。

### 1.2 汇编语言

汇编语言发展至今，有以下 3 类指令组成：

1. 汇编指令：机器码的助记符，有对应的机器码。
2. 伪指令：没有对应的机器码，由编译器执行，计算机并不执行。
3. 其他符号：如`+`、`-`、`*`、`/`等，由编译器识别，没有对应的机器码。

### 1.3 指令和数据

指令和数据是应用上的概念。在内存或磁盘上，指令和数据没有任何区别，都是二进制信息。CPU 在工作的时候把有的信息看作指令，有的信息看作数据，为同样的信息赋予了不同的意义。

例如，内存中的二进制信息 1000100111011000，计算机可以把它看作大小为 89D8H 的数据来处理，也可以将其看作指令 mov ax,bx 来执行。

```
1000100111011000	->	89D8H （数据）
1000100111011000	->	mov ax,bx（程序）
```

### 1.4 存储单元

8 个 bit 组成一个 Byte，即一个字节。微型机存储器的存储单元可以存储一个 Byte，即 8 个二进制位。

一个存储器有 128 个存储单元，它可以存储 128 个 Byte。

1KB=1024B		1MB=1024KB 

### 1.5 CPU 对存储器的读写

CPU 要进行数据的读写，需要和外部器件（芯片）进行下面 3 类信息的交互：

- 存储单元的地址（地址信息）
- 器件的选择，读或写的命令（控制信息）
- 读或写的数据（数据信息）

### 1.6 总线

地址总线的宽度决定了 CPU 的寻址能力。地址总线上能传送多少个不同的信息，CPU 就可以对多少个存储单元进行寻址。

数据总线的宽度决定了 CPU 与其他器件进行数据传送时的一次数据传送量。8 根数据总线一次可以传送一个 8 位二进制数据（一个字节）。

控制总线的宽度决定了 CPU 对系统中其他器件的控制能力。有多少根控制总线，就意味着 CPU 提供了对外部器件的多少种控制。

### 1.7 存储器芯片

随机存储器（RAM）：可读可写，带电存储，关机后存储的内容丢失。

只读存储器（ROM）：只读不写，关机后内容不丢失。

## 第 2 章 寄存器

一个典型的 CPU 由运算器、控制器、寄存器等器件构成，这些器件靠内部总线相连。

内部总线实现 CPU 内部各个器件之间的联系，外部总线实现CPU和主板上其他器件之间的联系。

### 2.1 通用寄存器

8086CPU（x86架构）的所有寄存器都是16位的，可以存放两个字节。

AX、BX、CX、DX 这4个寄存器通常用来存放一般性的数据，被称为通用寄存器。

这 4 个寄存器可分为两个独立使用的 8 位寄存器：

- AX 可分为 AH 和 AL；
- BX 可分为 BH 和 BL；
- CX 可分为 CH 和CL；
- DX 可分为 DH 和 DL；

例如，AX 的低 8 位（0 位\~7 位）构成了 AL 寄存器，高 8 位（8 位\~15 位）构成了 AH 寄存器。AH 和 AL寄存器是可以独立使用的 8 位寄存器。

| 寄存器 | 寄存器中的数据  | 所表示的值   |
| ------ | --------------- | ------------ |
| AX     | 100111000100000 | 20000(4E20H) |
| AH     | 01001110        | 78(4EH)      |
| AL     | 00100000        | 32(20H)      |

### 2.2 字在寄存器中的存储

出于对兼容性的考虑，8086CPU 可以一次性处理以下两种尺寸的数据：

- 字节：byte，一个字节 = 8个bit，可以存在 8 位寄存器中。
- 字：word，一个字 = 两个字节，分别称为这个字的高位字节和低位字节。

![image-20230420093226753](images/image-20230420093226753-16819759662311.png)

可用 3 种不同的进制表示图中 AX 里的数据：

- 十进制：20000
- 十六进制：4E20H
- 二进制：0100111000100000B

十六进制数的一位相当于二进制数的四位，如 0100111000100000 可表示成：4(0100)、E(1110)、2(0010)、0000(0000)四位十六进制数。

一个数据的十六进制形式左移 1 位，相当于乘以 16；一个数据的十进制形式左移 1 位，相当于乘以 10；一个 X 进制的数据左移 1 位，相当于乘以 X。

### 2.3 几条汇编指令

示例一：

| 汇编指令  | 控制 CPU 完成的操作                      | 用高级语言的语法描述 |
| --------- | ---------------------------------------- | -------------------- |
| mov ax,18 | 将 18 送入寄存器 AX                      | AX=18                |
| mov ah,78 | 将 78 送入寄存器 AH                      | AH=78                |
| add ax,8  | 将寄存器 AX 中的数值加上 8               | AX=AX+8              |
| mov ax,bx | 将寄存器 BX 中的数据送入寄存器 AX        | AX=BX                |
| add ax,bx | 将 AX 和 BX 中的数值相加，结果存在 AX 中 | AX=AX+BX             |

示例二：

原 AX 中的值：0000H，原 BX 中的值：0000H

| 程序段中的指令 | 指令执行后 AX 中的数据 | 指令执行后 BX 中的数据 |
| -------------- | ---------------------- | ---------------------- |
| mov ax,4E20H   | 4E20H                  | 0000H                  |
| add ax,1406H   | 6226H                  | 0000H                  |
| mov bx,2000H   | 6226H                  | 2000H                  |
| add ax,bx      | 8226H                  | 2000H                  |
| mov bx,ax      | 8226H                  | 8226H                  |
| add ax,bx      | 044CH                  | 8226H                  |

示例三：

原 AX 中的值：0000H，原 BX 中的值：0000H

| 程序段中的指令 | 指令执行后 AX 中的数据 | 指令执行后 BX 中的数据 |
| -------------- | ---------------------- | ---------------------- |
| mov ax,001AH   | 001AH                  | 0000H                  |
| mov bx,0026H   | 001AH                  | 0026H                  |
| add al,bl      | 0040H                  | 0026H                  |
| add ah,bl      | 2640H                  | 0026H                  |
| add bh,al      | 2640H                  | 4026H                  |
| mov ah,0       | 0040H                  | 4026H                  |
| add al,85H     | 00C5H                  | 4026H                  |
| add al,93H     | 0158H                  | 4026H                  |

示例四：

| 程序段中的指令 | 指令执行后相关寄存器中的数据 |
| -------------- | ---------------------------- |
| mov ax,62627   | AX=F4A3H                     |
| mov ah,31H     | AX=31A3H                     |
| mov al,23H     | AX=3123H                     |
| add ax,ax      | AX=6246H                     |
| mov bx,826CH   | BX=826CH                     |
| mov cx,ax      | CX=6246H                     |
| mov ax,bx      | AX=826CH                     |
| add ax,bx      | AX=04D8H                     |
| mov al,bh      | AX=0482H                     |
| mov ah, bl     | AX=6C82H                     |
| add ah,ah      | AX=D882H                     |
| add al,6       | AX=D888H                     |
| add al,al      | AX=D810H                     |
| mov ax,cx      | AX=6246H                     |

### 2.4 物理地址

CPU 访问内存单元时，要给出内存单元的地址。所有的内存单元构成的存储空间是一个一维的线性空间，每一个内存单元在这个空间中都有唯一的地址，这个唯一的地址被称为物理地址。

CPU 通过地址总线送入存储器的，必须是一个内存单元的物理地址。在 CPU 向地址总线上发出物理地址之前，不需要再内部先形成这个物理地址。

地址加法器采用 **物理地址=段地址×16+偏移地址**的方法合成物理地址。段地址×16 可以看作是基础地址，即**物理地址=基础地址+偏移地址**。

示例一：

段地址 1230H，偏移地址 00C8H，则：

物理地址=段地址×16+偏移地址= 12300H + 00C8H = 123C8H

CPU 可以用不同的段地址和偏移地址形成同一个物理地址。例如，CPU 要访问 21F60H 单元，则它给出的段地址 SA 和偏移地址 EA 满足 SA×16+EA = 21F60H 即可。

示例二：

| 物理地址 | 段地址 | 偏移地址 |
| -------- | ------ | -------- |
| 21F60H   | 2000H  | 1F60H    |
|          | 2100H  | 0F60H    |
|          | 21F0H  | 0060H    |
|          | 21F6H  | 0000H    |
|          | 1F00H  | 2F60H    |

### 2.5 段寄存器

8086CPU 有 4 个段寄存器：CS、DS、SS、ES。当 8086CPU 要访问内存时，这 4 个段寄存器提供内存单元的段地址。

CS 和 IP 是8086CPU 中两个最关键的寄存器，指示了 CPU 当前要读取指令的地址。CS 为代码寄存器，IP 为指令寄存器。在 8086PC 机中，任意时刻，设 CS 中的内容为 M，IP 中的内容为 N，8086CPU 将从内存 M×16+N 单元开始，读取一条指令并执行，即 CPU 将CS:IP 指向的内容当作指令执行。

mov 指令被称作传送指令，mov 指令不能用于设置 CS、IP 的值。转移指令可以改变 CS、IP 的内容，jmp 指令是最简单的偏移指令。

若想同时修改 CS、IP 的内容，使用 `jmp 段地址:偏移地址` 指令，功能为：从指令中给出的段地址修改 CS，偏移地址修改 IP。

若想只修改 IP 的内容，使用 `jmp 某一合法寄存器` 指令，功能为：用寄存器中的值修改 IP。

示例一：

jmp 2AE3:3，执行后：CS=2AE3H，IP=0003H，CPU 将从 2AE33H 处读取指令。

jmp ax，执行前：ax=1000H，CS=2000H，IP=0003H，执行后：ax=1000H，CS=2000H，IP=1000H。

示例二：

将一段代码存放在 123B0H~123B9H 内存单元中，将其定义为代码段，如果要让这段代码得到执行，可以设 CS=123BH、IP=0000H。

## 第3章 寄存器（内存访问）

### 3.1 内存中字的存储

CPU 中，用 16 位寄存器来存储一个字。高 8 位存放高位字节，低 8 位存放低位字节。图中用 0、1 两个内存单元存放数据 20000(4E20H)。0、1 两个内存单元用来存储一个字，可以看作一个起始地址为 0 的字单元（存放一个字的内存单元，由 0、1 两个字节单元组成）。

示例一：

存放数据 20000(4E20H) 和 18(0012H)。

![image-20230420111423486](images/image-20230420111423486.png)

### 3.2 DS 和 \[address\]

CPU 要读写一个内存单元的时候，必须先给出这个内存单元的地址，在 8086PC 中，内存地址由段地址和偏移地址组成。

8086CPU 中有一个 DS 寄存器，通常用来存放要访问数据的段地址。例如将10000H(1000:0) 中的内容读取到AL中，可以用如下的程序段进行：

```
mov bx,1000H
mov ds,bx
mov al,[0]
```

可以使用 mov 指令将一个内存单元中的内容送入一个寄存器中。指令格式为 `mov 寄存器名,内存单元地址`。

`[address]` 表示一个偏移地址为 address 的内存单元，例如，`[0]`  中的 0 表示内存单元的偏移地址。但只有偏移地址是不能定位一个内存单元的，指令执行时，CPU 自动取 ds 中的数据作为内存单元的段地址。

8086CPU 不支持将数据直接送入段寄存器的操作，ds 是一个段寄存器，需要先将 1000H 先送入 bx 这样的一般寄存器，再将 bx 中的内容送入 ds。

### 3.3 字的传送

示例一：

![image-20230420113404161](images/image-20230420113404161.png)

内存中的情况如图所示，指令执行后寄存器 ax、bx、cx 中的值：

```
mov ax,1000H		
mov ds,ax			
mov ax,[0]
mov bx,[2]
mov cx,[1]
add bx,[1]
add cx,[2]
```

| 程序段中的指令 | 指令执行后相关寄存器中的数据 |
| -------------- | ---------------------------- |
| mov ax,1000H   | ax=1000H                     |
| mov ds,ax      | ds=1000H                     |
| mov ax,[0]     | ax=1123H                     |
| mov bx,[2]     | bx=6622H                     |
| mov cx,[1]     | cx=2211H                     |
| add bx,[1]     | bx=8833H                     |
| add cx,[2]     | cx=8833H                     |

### 3.4 mov指令

mov 指令可以有以下几种形式：

| 指令形式               | 示例                                        |
| ---------------------- | ------------------------------------------- |
| mov 寄存器，数据       | mov ax,8                                    |
| mov 寄存器，寄存器     | mov ax,bx                                   |
| mov 寄存器，内存单元   | mov ax,[0]                                  |
| mov 内存单元，寄存器   | mov [0],ax                                  |
| mov 段寄存器，寄存器   | mov ds,ax                                   |
| mov 寄存器，段寄存器   | mov ax,ds                                   |
| mov 内存单元，段寄存器 | mov ax,1000H<br />mov ds,ax<br />mov [0],cs |
| mov 段寄存器，内存单元 | mov ax,1000H<br />mov ds,ax<br />mov ds,[0] |

### 3.5 数据段

用 123B0H~123B9H这段内存空间来存放数据，段地址为 123BH，长度为 10 个字节。

累加这个数据段中的前 3 个单元中的数据，代码如下：

```
mov ax,123BH	
mov ds,ax		;将 123BH 送入ds中，作为数据段的段地址
mov al,0		;用 al 存放累加结果
add al,[0]		;将数据段第一个单元（偏移地址为 0）中的数值加到 al 中
add al,[1]		;将数据段第二个单元（偏移地址为 1）中的数值加到 al 中
add al,[2]		;将数据段第三个单元（偏移地址为 2）中的数值加到 al 中
```

累加这个数据段中的前 3 个字型数据，代码如下：

```
mov ax,123BH	
mov ds,ax		;将 123BH 送入ds中，作为数据段的段地址
mov ax,0		;用 ax 存放累加结果
add ax,[0]		;将数据段第一个单元（偏移地址为 0）中的数值加到 ax 中
add ax,[2]		;将数据段第二个单元（偏移地址为 2）中的数值加到 ax 中
add ax,[4]		;将数据段第三个单元（偏移地址为 4）中的数值加到 ax 中
```

注意，一个字型数据占两个单元，所以偏移地址是0、2、4。

### 3.6 push、pop 指令

栈的操作规则：LIFO(Last In First Out，后进先出)。

8086CPU 提供入栈和出栈指令，最基本的两个是 PUSH（入栈） 和 POP（出栈）。出栈和入栈操作都是以字为单位进行的。

8086CPU 中有两个寄存器，段寄存器 SS 和寄存器 SP，栈顶的段地址存放在 SS 中，偏移地址存放在 SP 中。**任意时刻，SS:SP 指向栈顶元素**。栈顶的变化范围最大为：0~FFFFH。一个栈段的容量最大为 64KB。

push 指令的执行步骤：

- SP=SP-2
- 向 SS:SP 指向的字单元中送入数据

pop 指令的执行步骤：

- 从 SS:SP 指向的字单元中读取数据
- SP=SP+2

push 和 pop 指令可以有以下几种形式：

| 指令形式      | 说明                                                     |
| ------------- | -------------------------------------------------------- |
| push 寄存器   | 将一个寄存器中的数据入栈                                 |
| pop 寄存器    | 出栈，用一个寄存器接收出栈的数据                         |
| push 段寄存器 | 将一个段寄存器中的数据入栈                               |
| pop 段寄存器  | 出栈，用一个段寄存器接收出栈的数据                       |
| push 内存单元 | 将一个内存字单元处的字入栈（注意：栈操作都是以字为单位） |
| pop 内存单元  | 出栈，用一个内存子单元接收出栈的数据                     |

示例一：

将 10000H~1000FH 这段空间当作栈，初始状态栈是空的，将AX、BX、DS 中的数据入栈。

```
mov ax,1000H
mov ss,ax
mov sp,0010H

push ax
push bx
push ds
```

示例二：

将 10000H~1000FH 这段空间当作栈，初始状态栈是空的，设置 AX=001AH，BX=001BH，利用栈，交换 AX 和 BX 中的数据。

```
mov ax,1000H
mov ss,ax
mov sp,0010H

mov ax,001AH
mov bx,001BH

push ax
push bx

pop ax
pop bx
```

示例三：

在 10000H 处写入字型数据 2266H，使用 mov 指令：

```
mov ax,1000H
mov ds,ax
mov ax,2266H
mov [0],ax
```

在 10000H 处写入字型数据 2266H，但**不使用 `mov 内存单元,寄存器`** 指令：

```
mov ax,1000H
mov ss,ax
mov sp,2
mov ax,2266H
push ax
```

### 3.7 段的综述

我们可以用一个段存放数据，将它定义为“数据段”；可以用一个段存放代码，将它定义为“代码段”；可以用一个段当作栈，将它定义为“栈段”。

对于数据段，将段地址放在 DS 中，使用 mov、add、sub等访问内存单元的指令。

对于代码段，将段地址放在 CS 中，将段中第一条指令的偏移地址放在 IP 中。

对于栈段，将段地址放在 SS 中，将栈顶单元的偏移地址放在 SP 中，使用 pop、push 指令进行栈操作。

## 第 4 章 \[BX\] 和 loop 指令

### 4.1 \[bx\]

[bx] 表示一个内存单元，它的偏移地址在 bx 中。例如，如下指令：

```
mov ax,[bx]
```

将一个内存单元的内容送入 ax，这个内存单元的长度为 2 字节（字单元），存放一个字，偏移地址在 bx 中，段地址在 ds 中。

```
mov al,[bx]
```

将一个内存单元的内容送入 al，这个内存单元的长度为 1 字节（字节单元），存放一个字节，偏移地址在 bx 中，段地址在 ds 中。 

### 4.2 loop 指令

loop指令的格式是：`loop 标号`。用 cx 和 loop 指令配合实现循环功能的程序框架如下：

```
	mov cx,循环次数
s:
	循环执行的程序段
	loop s
```

CPU 执行 loop 指令的时候，要进行两步操作：

- (cx)=(cx)-1
- 判断 cx 中的值，不为零则转至标号处执行程序，如果为零则向下执行

### 4.3 段前缀

```
mov ax,ds:[bx]
```

以上代码将一个内存单元的内容送入 ax，这个内存单元的长度为 2 字节（字单元），存放一个字，偏移地址在 bx 中，段地址在 ds 中。

```
mov ax,cs:[bx]
```

以上代码将一个内存单元的内容送入 ax，这个内存单元的长度为 2 字节（字单元），存放一个字，偏移地址在 bx 中，段地址在 cs 中。

这些出现在访问内存单元的指令中，用于显式地指明内存单元的段地址的 `ds:` 、`cs:` 、`ss:` 、`es:` ，在汇编语言中称为段前缀。

## 第 5 章 x86/x64 寄存器

### 5.1 x86 架构

一般的 IA-32（Intel Architecture，32-bit）即 x86 架构的处理器中包含以下寄存器：

- 通用寄存器 EAX、EBX、ECX、EDX、ESI、EDI。
- 栈顶指针寄存器 ESP、栈底指针寄存器 EBP。
- 指令计数器 EIP（保存下一条即将执行的指令的地址）。
- 段寄存器 CS、DS、SS、ES、FS、GS。

### 5.2 x64 架构

x86-64 架构在以上这些寄存器的基础上，将前缀的 E 改成 R，以标记 64 位，同时增加了 R8~R15 这8个通用寄存器。

R8~R15 进行拆分时的明明规则为 R8d（低 32 位）、 R8w（低 16 位）、 R8b（低 8 位）。

对于 16 位的情况，将前缀 E 全部去掉。

## 第 6 章 标志寄存器

8086CPU 的标志寄存器有 16 位，其中存储的信息通常被称为程序状态字（PSW）。

标志寄存器是按位起作用的，每一位都有专门的含义，记录特定的信息。

### 6.1 ZF 标志

ZF：零标志（Zero Flag），当运算结果全零时置 1。

它记录相关指令执行后，其结果是否为 0。

### 6.2 PF 标志

PF：奇偶校验标志（Parity Flag），当运算结果的最低有效字节有偶数个 1 时置 1。

它记录相关指令执行后，其结果的所有 bit 位中 1 的个数是否为偶数。

### 6.3 SF 标志

SF：符号标志（Sign Flag），有符号整形的符号位为 1 时置 1，代表这是一个负数。

它记录相关指令执行后，其结果是否为负。

### 6.4 CF 标志

CF：进位标志（Carry Flag），运算结果向最高位以上进位时置 1，用来判断无符号数的溢出。

在进行无符号数运算的时候，它记录了运算结果的最高有效位向更高位的进位值，或者从更高位的借位值。

### 6.5 OF 标志

OF：溢出标志（Overflow Flag），运算结果在被操作数是有符号数且溢出时置 1。

它记录了有符号数运算的结果是否发生了溢出。

### 6.6 AF 标志

AF：辅助进位标志（Auxiliary Carry Flag），当运算结果在第 3 位进位时置 1。

## 第 7 章 寻址方式

在 X86/x64 架构中，寄存器间间接寻址、基址寻址、变址寻址、基址加变址这 4 种寻址方式在实现的功能方便几乎相同，但语义上是由区别的。

在 16 位时代，这 4 种寻址方式不可混用。

在现代编译器中，编译器会根据语义和优化选择合适的寻址方式。

### 7.1 立即寻址

例如 1000H，表示 1000H 这个数字。

### 7.2 直接寻址

例如 [1000H]，表示地址为 1000H 的内存单元。

### 7.3 寄存器寻址

例如 RAX，表示 RAX 这个寄存器。

### 7.4 寄存器间接寻址

例如 [RAX]，表示以 RAX 中存放的数作为地址的内存单元。

### 7.5 基址寻址

例如 [RBP+10H]，表示将 RBP 中存放的数作为基址，加上 10H，访问这个运算后地址的内存单元。

### 7.6 变址寻址

例如 [RDI+10H]，表示将 RDI 作为变址寄存器，将其中的数字加上 10H，访问这个运算后地址的内存单元。

### 7.7 基址加变址寻址

例如 [RBX+RSI+10H]，同上。

## 第 8 章 汇编指令

x86/x64 汇编指令的基本格式如下：

```
操作码 [操作数 1] [操作数 2] 
```

常见的汇编指令：

| 指令类型   | 操作码 | 指令示例                | 对应作用                             |
| ---------- | ------ | ----------------------- | ------------------------------------ |
| 数据传送   | mov    | mov rax,rbx             | rax=rbx                              |
| 数据传送   | mov    | mov qword ptr [rdi],rax | *(rdi)=rax                           |
| 取地址     | lea    | lea rax,[rsi]           | rax=&*(rsi)                          |
| 算数运算   | add    | add rax,rbx             | rax +=rbx                            |
| 算数运算   | add    | add qword ptr [rdi],rax | *(rdi)+=rax                          |
| 算数运算   | sub    | sub rax,rbx             | rax-=rbx                             |
| 逻辑运算   | and    | and rax,rbx             | rax &=rbx                            |
| 逻辑运算   | xor    | xor rax,rbx             | rax ^=rbx                            |
| 函数调用   | call   | call 0x401000           | 执行 0x40100 地址的函数              |
| 函数返回   | ret    | ret                     | 函数返回                             |
| 比较       | cmp    | cmp rax,rbx             | 根据 rax 与 rbx 比较的结果改变标志位 |
| 无条件跳转 | jmp    | jmp 0x40100             | 跳到 0x401000 地址执行               |
| 栈操作     | push   | push rax                | 将 rax 的值压入栈中                  |
| 栈操作     | pop    | pop rax                 | 从栈上弹出一个元素放入 rax           |

汇编语言中的条件跳转指令有很多，它们会根据标志位的情况进行条件跳转。在条件跳转指令前往往存在用于比较的 cmp 指令，会根据比较结果对标志位进行相应设置。

常见的条件跳转指令：

| 指令        | 全称                                       | cmp a,b 条件      | flag 条件 |
| ----------- | ------------------------------------------ | ----------------- | --------- |
| jz/je       | jump if zero/equal                         | a = b             | ZF = 1    |
| jnz/jne     | jump if not zero/equal                     | a !=b             | ZF = 0    |
| jb/jnae/jc  | jump if below/not above or equal/carry     | a < b，无符号数   | CF = 1    |
| ja/jnbe     | jump if above/not below or equal           | a > b，无符号数   |           |
| jna/jbe     | jump if not above/below or equal           | a <=b，无符号数   |           |
| jnc/jnb/jae | jump if not carry/not below/above or equal | a >= b，无符号数  | CF = 0    |
| jg/jnle     | jump if greater/not less or equal          | a > b，有符号数   |           |
| jge/jnl     | jump if greter or equal/not less           | a  >= b，有符号数 |           |
| jl/jnge     | jump if less/not greater or equal          | a < b，有符号数   |           |
| jle/jng     | jump if less or equal/not greater          | a <= b，有符号数  |           |
| jo          | jump if overflow                           |                   | OF = 1    |
| js          | jump if signed                             |                   | SF = 1    |

